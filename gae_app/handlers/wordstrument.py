"""
wordstrument.py:

Handler for Wordstrument

* Author:       Mitchell Bowden <mitchellbowden AT gmail DOT com>
* License:      MIT License: http://creativecommons.org/licenses/MIT/
"""

from google.appengine.ext import webapp
from google.appengine.ext.webapp import template

import os
import traceback
import time
import yaml
import logging
import urllib

from lib.sequence import Sequence
import lib.tablature as tablature
from lib.scale import get_scale_names

from lib.MidiFile import MIDIFile

class WordstrumentHandler(webapp.RequestHandler):
  # GET
  def get(self):
    input = self.request.get('q')
    if input is not None and input != '':
      template_values = self.run_wordstrument(
        urllib.unquote_plus(self.request.get('q')), 
        urllib.unquote_plus(self.request.get('s'))
      )
    else:
      template_values = {
        'http_get': True,
        'scales': get_scale_names(),
      }

    path = os.path.join(
      os.path.dirname(__file__), '..', 'templates', 'wordstrument.html'
    )
    self.response.out.write(template.render(path, template_values))

  # POST
  def post(self):
    template_values = self.run_wordstrument(self.request.get('content'), self.request.get('scale'), self.request.get('midi'))

    path = os.path.join(
      os.path.dirname(__file__), '..', 'templates', 'wordstrument.html'
    )

    self.response.out.write(template.render(path, template_values))

  def run_wordstrument(self, text_in, scale, midi=None):
    if text_in is None or text_in == '':
      template_values = {
        'http_get': True,
        'error': "No text to put into the wordstrument. Try again."
      }
      return template_values

    text_in = text_in.strip()
    raw_notes = Sequence(text_in)
    raw_notes_str = raw_notes.to_str()

    raw_notes.set_scale(scale.strip())
    raw_notes.snap_to_key()
    raw_notes.snap_to_time_signature()
    in_key_notes_str = raw_notes.to_str()

    # tablature
    fretboard = tablature.GuitarFretboard(tablature.six_string_std)
    tab = tablature.GuitarTabSequence(fretboard, raw_notes)

    template_values = {
      'http_get': False,
      'text_in': text_in,
      'root': raw_notes.get_root(),
      'scale_used': raw_notes.get_scale_name(),
      'scales': get_scale_names(),
      'vextab_codes': tab.split_str(),
      'abc_notation': raw_notes.to_abc_notation(),
      'chrange': range(128),
      'url_query': urllib.urlencode(dict([['q',text_in],['s',raw_notes.get_scale_name()]]))
    }

    return template_values


# === Midi generation ===

class MidiHandler(webapp.RequestHandler):
  def get(self):
    abc_notation = urllib.unquote_plus(self.request.get('n'))
    self.response.headers['Content-Type'] = 'audio/mid'
    GenerateMidi(abc_notation, self.response.out)

def GenerateMidi(notes, out, tempo=160):
  song = MIDIFile(1)
  track = 0
  time = 0
  channel = 0
  song.addTrackName(track, time, "Generated by Midi Server")
  song.addTempo(track, time, tempo)
  song.addProgramChange(track, channel, time, 25)
  def AddNote(pitch, time, duration):
    song.addNote(track, channel, pitch, time, duration, 100)
  def SetEndTime(time):
    # add a no-op event to make sure we wait one beat the end,
    # to add time for the last note to fade
    song.addTempo(track, time + 1, 120)
  Parse(notes, AddNote, SetEndTime)
  song.writeFile(out)


letters = 'CDEFGAB'
pitches = [60, 62, 64, 65, 67, 69, 71]
letter_to_pitch = dict(zip(letters + letters.lower(), 
                      pitches + [p + 12 for p in pitches]))
REST = "rest"

def Parse(music, addNote, setEndTime):
  class State(object):
    def __init__(self):
      self.time = 0
      self.pitch = None
      self.accidental = 0
      self.number = 0
      self.slash = False
    def Parse(self, music):
      for c in music:
        if c in "CDEFGABcdefgab":
          self.FinishNote()
          self.pitch = letter_to_pitch[c]
        elif c == "'":
          self.pitch += 12
        elif c == ",":
          self.pitch -= 12
        elif c == 'z':
          self.FinishNote()
          self.pitch = REST
        elif c in "0123456789":
          self.number = self.number * 10 + int(c)
        elif c == '/':
          self.slash = True
          self.number = 0
        elif c == '^':
          self.accidental += 1
        elif c == '_':
          self.accidental -= 1
      self.FinishNote()
      setEndTime(self.time)
    def FinishNote(self):
      if self.slash:
        if self.number == 0:
          beats = 0.5
        else:
          beats = 1.0 / self.number
      else:
        if self.number == 0:
          beats = 1
        else:
          beats = self.number
      if self.pitch == REST:
        self.time += beats
      elif self.pitch is not None:
        pitch = self.pitch + self.accidental
        if pitch >= 0 and pitch <= 127:
          addNote(pitch, self.time, beats)
        self.time += beats
      self.pitch = None
      self.accidental = 0
      self.number = 0
      self.slash = False

  State().Parse(music)
